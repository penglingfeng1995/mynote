# 概述

sharding-jdbc 是当当网 开源的一款数据库框架，用于分库分表，读写分离，分布式事务。后升级为 sharding-sphere ，再后来捐赠给了 apache 进行，然后成为顶级项目，同时还有子项目 elastic-job。

由于几经波折，依赖的 坐标也是会不一样。注意自己使用的版本。

1.x

```xml
<dependency>
    <groupId>com.dangdang</groupId>
    <artifactId>sharding-jdbc-core</artifactId>
    <version>1.5.4</version>
</dependency>
```

2.x

```xml
<dependency>
    <groupId>io.shardingjdbc</groupId>
    <artifactId>sharding-jdbc-core</artifactId>
    <version>2.0.3</version>
</dependency>
```

3.x

```xml
<dependency>
    <groupId>io.shardingsphere</groupId>
    <artifactId>sharding-jdbc-core</artifactId>
    <version>3.1.0</version>
</dependency>
```

4.x

```xml
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-core</artifactId>
    <version>4.1.1</version>
</dependency>
```

5.x

```xml
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>shardingsphere-jdbc-core</artifactId>
    <version>5.0.0-alpha</version>
</dependency>
```

由于 5.x 还不是正式版本，这里使用 4.x 的版本。

# 分库分表

## 原生使用

再mian方法中，我们获取了数据源，开启连接，执行sql。

但是数据源的定义方式发生了变化。

```java
public static void main(String[] args) throws SQLException {
    DataSource dataSource = getDataSource();
    Connection connection = dataSource.getConnection();
    String sql = "insert into t_order(order_id,user_id,username) values (?,?,?)";
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    for (int i = 0; i < 10; i++) {
        preparedStatement.setInt(1, i);
        preparedStatement.setInt(2, i);
        preparedStatement.setString(3, "张三" + i);
        preparedStatement.execute();
    }
}

// 实例化数据源
private static DataSource getDataSource() throws SQLException {
    Map<String, DataSource> dataSourceMap = new HashMap<>();
	// 定义了两个数据源，并放入map中
    HikariDataSource dataSource0 = new HikariDataSource();
    dataSource0.setJdbcUrl("jdbc:mysql://192.168.24.130:3306/dev0");
    dataSource0.setUsername("root");
    dataSource0.setPassword("123456");
    dataSourceMap.put("dev0", dataSource0);

    HikariDataSource dataSource1 = new HikariDataSource();
    dataSource1.setJdbcUrl("jdbc:mysql://192.168.24.130:3306/dev1");
    dataSource1.setUsername("root");
    dataSource1.setPassword("123456");
    dataSourceMap.put("dev1", dataSource1);
	
    // 定义分库分表规则
    TableRuleConfiguration orderTableRule = 
        new TableRuleConfiguration("t_order", "dev${0..1}.t_order${0..1}");
    // 分库规则，按照user_id取余数分库
    orderTableRule.setDatabaseShardingStrategyConfig(
        new InlineShardingStrategyConfiguration("user_id", "dev${user_id % 2}"));
    // 分表规则，按照order_id取余数分表
    orderTableRule.setTableShardingStrategyConfig(
        new InlineShardingStrategyConfiguration("order_id", "t_order${order_id % 2}"));
	// 注册规则
    ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();
    shardingRuleConfig.getTableRuleConfigs().add(orderTableRule);
	// 创建数据源
    return ShardingDataSourceFactory.createDataSource(dataSourceMap, shardingRuleConfig, new Properties());
}
```

我们定义两个数据库 ，dev0 和 dev1 ，分别创建两个表

```sql
create table t_order0(
    order_id int,
    user_id int,
    username varchar(64)
);

create table t_order1(
    order_id int,
    user_id int,
    username varchar(64)
);
```

执行，发现，数据被插入到不同数据库的不同表中。