# mybatis plus

该框架可以无缝集成mybatis，大大简化单表操作

## 入门

创建一个 springboot项目，引入依赖

该依赖会自动引入 mybatis,mybatis-spring,springboot-starter-jdbc，无需重复引入以免冲突。

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.3.2</version>
</dependency>
```

配置数据库连接

```yaml
spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/student
    driver-class-name: com.mysql.cj.jdbc.Driver
```

启动类指定扫描mapper方式

```java
@SpringBootApplication
@MapperScan(annotationClass = Repository.class)
public class MybatisplusApplication {
```

现有以下表

```sql
create table student
(
    id           bigint auto_increment
        primary key,
    student_name varchar(255) null
);
INSERT INTO student (id, name) VALUES (1, '张三');
INSERT INTO student (id, name) VALUES (2, '李四');
```

编写对应的实体类

```java
import lombok.Data;

@Data
public class Student {

    private Long id;
    private String name;
}
```

编写mapper

```java
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.plf.mybatisplus.model.Student;
import org.springframework.stereotype.Repository;

@Repository
public interface StudentMapper extends BaseMapper<Student> {
}
```

即可使用 StudentMapper

```java
Student student = studentMapper.selectById(1L);
List<Student> students = studentMapper.selectList(null);
```

## 常用注解

`@TableName` 在实体类上指定表名，当表名和类名不一致时。

`@TableField` 实体类的属性上指定。

`@TableId` 用来指定主键，默认为`id`,还可以指定主键的策略，如`IdType.AUTO` 自增长

## CRUD接口

### insert

调用 `int insert(T entity);` ，设置一个实例即可

```java
Student student = new Student();
student.setName("王五");
int row = studentMapper.insert(student);
```

### delete

提供了四种方式

```java
// 按主键删除
int deleteById(Serializable id);
// 按columnMap删除
int deleteByMap(@Param("cm") Map<String, Object> columnMap);
// 按条件删除
int delete(@Param("ew") Wrapper<T> wrapper);
// 按主键批量删除
int deleteBatchIds(@Param("coll") Collection<? extends Serializable> idList);
```

使用

```java
// 按主键删除
studentMapper.deleteById(1L);
// 按columnMap删除
Map<String ,Object> columnMap=new HashMap<>();
columnMap.put("id",2L);
columnMap.put("student_name","张三");
studentMapper.deleteByMap(columnMap);
// 按条件删除
int row = studentMapper.delete(new QueryWrapper<Student>().lambda()
                               .eq(Student::getName, "张三")
                               .eq(Student::getId, 3L));
// 按主键批量删除
List<Long> ids = Arrays.asList(new Long[]{4L, 5L});
studentMapper.deleteBatchIds(ids);
```

### update

提供两个修改接口

```java
// 根据id修改
int updateById(@Param(Constants.ENTITY) T entity);
// 根据条件修改
int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper<T> updateWrapper);
```

使用

```java
// 根据id修改
Student student = new Student();
student.setId(6L);
student.setName("王五");
studentMapper.updateById(student);
// 根据条件修改
Student student = new Student();
student.setName("赵六");
studentMapper.update(student,new LambdaQueryWrapper<Student>()
                     .eq(Student::getId,6L));
```

### select

查询提供了最丰富的接口

```java
// 通过id
T selectById(Serializable id);
// id批量
List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);
// columnMap
List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);
// 按条件查一条
T selectOne(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
// 按条件查count
Integer selectCount(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
// 按条件查list
List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
// 按条件查询，封装为map
List<Map<String, Object>> selectMaps(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
// 条件查询，只返回第一个字段的值
List<Object> selectObjs(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
// 带分页的查询条件
<E extends IPage<T>> E selectPage(E page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
// 带分页的查询，返回Map
<E extends IPage<Map<String, Object>>> E selectMapsPage(E page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
```

使用

```java
Student student = studentMapper.selectById(8L);

List<Student> students = studentMapper.selectBatchIds(Arrays.asList(6L, 7L));

List<Student> zStudents = studentMapper.selectList(new LambdaQueryWrapper<Student>()
                                                   .like(Student::getName, "张"));

Integer zCount = studentMapper.selectCount(new LambdaQueryWrapper<Student>()
                                           .like(Student::getName, "张"));

Map<String,Object> columnMap=new HashMap<>();
columnMap.put("student_name","张三");
List<Student> students1 = studentMapper.selectByMap(columnMap);

List<Map<String, Object>> mapList = studentMapper.selectMaps(new LambdaQueryWrapper<Student>()
                                                             .like(Student::getName, "张"));

List<Object> objectList = studentMapper.selectObjs(new LambdaQueryWrapper<Student>()
                                                   .like(Student::getName, "张"));

Student selectOne = studentMapper.selectOne(new LambdaQueryWrapper<Student>()
                                            .like(Student::getName, "赵"));
```

