# 国际化

### 1,配置国际化资源文件

在src下配置i18n_zh_CN.properties和i18n_en_US.properties

内容为

```properties
username=用户名
password=密码
```

和

```properties
username=UserName
password=PassWord
```

### 2,根据指定的前缀读取资源文件

```xml
<bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
		<property name="basename" value="classpath:i18n" />
</bean>
```

### 3，页面取值

导入spring的标签库

```jsp
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
```

取值,code对应properties文件中的键

```html
<spring:message code="username"></spring:message>
<br>
<spring:message code="password"></spring:message>
```

在火狐浏览器中设置语言，刷新页面可以看到效果

**exception:**如果jsp加载出异常,在web.xml中添加一个监听器，再次读取一次核心配置文件

```xml
<!-- needed for ContextLoaderListener -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring.xml</param-value>
</context-param>

<!-- Bootstraps the root web application context before servlet initialization -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```



## 自动切换语言

通过超链接跳转页面,过程中改变 了session的语言设置

跳转的控制器，就跳转到当前页面

```java
@RequestMapping("toggleLang")
public String toggleLang() {
    return "/myHtml/in.jsp";
}
```

添加拦截器,设置参数名，可通过参数名改变本地语言状态，本地语言信息会存到session中

```xml
<!-- 把本地信息设置在session中 -->
<bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"></bean>
<!-- 添加语言改变拦截器，通过参数名language来获取 -->
<mvc:interceptors>
    <bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
        <property name="paramName" value="language" />
    </bean>
</mvc:interceptors>
```

页面上设置超链接，带本地参数请求过去，会被拦截器读取刚设置的参数名对应的值，并存到session中

```html
<a href="/spring-mvc-02/toggleLang.do?language=zh_CN">中文</a><br>
<a href="/spring-mvc-02/toggleLang.do?language=en_US">english</a><br>
```

# 数据校验

导入数据校验所需要的jar包，validation-api-2.0.1.Final.jar,jboss-logging-3.3.0.Final.jar,hibernate-validator-5.3.4.Final.jar和classmate-1.3.0.jar

在需要校验的属性前加注解

```java
@NotEmpty
private String username;
```

在controller方法的入参设置是否校验,使用@Valid

```java
@RequestMapping("testValid")
@ResponseBody
public String testValid(@Valid User user) {
    return "true";
}
```

如果请求没有这个参数则会400，有参则正常访问

### BindingResult

通过BIndingResult，在有错的时候不会直接400，而是得到错误信息做进一步处理

```java
@RequestMapping("testValid")
@ResponseBody
//添加BindingResult对象作为参数,如果绑定失败会实例化这个对象，并保存错误信息
public String testValid(@Valid User user,BindingResult result) {
    //判断是否绑定失败
    if(result.hasErrors()) {
        //得到所有的错误信息
        List<ObjectError> errors= result.getAllErrors();
        //迭代错误信息
        for (ObjectError objectError : errors) {
            //得到配置的message
            String message= objectError.getDefaultMessage();
            System.out.println(message);
            //有错直接返回错误信息,或者错误页面
            return message;
        }
    }
    //没错返回true,或者成功页面
    return "true";
}
```

