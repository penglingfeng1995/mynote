# 上传文件

导入jar包。commons-fileupload，和commons-io

配置部件解析器,这里的bean的name一定要是这个

```xml
<bean  name="multipartResolver"
      class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="defaultEncoding" value="UTF-8" />
</bean>
```

编写form表单提交,记得加`enctype="multipart/form-data"`

```html
<form action="/spring-mvc-02/upload.do" method="post" enctype="multipart/form-data">
	<input type="file" name="file">
	<input type="submit" value="上传">
</form>
```

对应的controller,直接使用MultipartFile作为入参，拿到file对象，调用transferTo方法保存

```java
@RequestMapping("upload")
@ResponseBody
public String upload(MultipartFile file) throws IOException {
    //得到文件原始名称
    String filename = file.getOriginalFilename();
    //保存文件
    file.transferTo(new File("D:\\" + filename));
    return "true";
}
```

# 文件下载

写一个超链接用来下载文件

```html
<a href="/spring-mvc-02/download.do">下载</a>
```

对应的控制器

```java
@RequestMapping("download")
public ResponseEntity<byte[]> download() throws IOException {
    // 得到文件对象
    File file = new File("E:\\NwtDownload\\aaa.jpg");
    // 设置文件名称，并解决中文乱码
    String filename = new String("你好.jpg".getBytes("UTF-8"), "ISO-8859-1");
    // 设置头部信息
    HttpHeaders headers = new HttpHeaders();
    // 以附件的形式打开文件,设置文件名
    headers.setContentDispositionFormData("attachment", filename);
    // 内容采用八位字节流
    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
    //得到响应实体
    ResponseEntity<byte[]> responseEntity = new ResponseEntity<byte[]> (FileUtils.readFileToByteArray(file), headers,HttpStatus.OK);
    //返回响应实体
    return responseEntity;
}
```

# 拦截器

实现HandlerInterceptor接口，并注册

```java
public class TestInterceptor implements HandlerInterceptor {

	@Override
	public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)
			throws Exception {
		System.out.println("TestInterceptor.afterCompletion()");
		
	}

	@Override
	public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)
			throws Exception {
		System.out.println("TestInterceptor.postHandle()");
		
	}

	@Override
	public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception {
		System.out.println("TestInterceptor.preHandle()");
		return true;
	}

}

```

在xml中注册

```xml
<mvc:interceptors>
    <bean class="com.znsd.plf.controller.TestInterceptor"></bean>
</mvc:interceptors>
```

直接配置的话，会在所有controller执行时执行，按照一下顺序

```java
//返回true会继续往下执行
TestInterceptor.preHandle()
TestInterceptor.postHandle()
TestInterceptor.afterCompletion()
```

指定作用范围,通过mapping指定拦截范围，exclude-mapping指定不拦截的范围

```xml
<mvc:interceptors>
		<mvc:interceptor>
			<mvc:mapping path="/test" />
			<mvc:exclude-mapping path="/user" />
			<bean class="com.znsd.plf.controller.TestInterceptor"></bean>
		</mvc:interceptor>
	</mvc:interceptors>
```

# 异常处理

当controller中发生错误时，配置异常处理器转发到专用错误页面,用法和其他方法一致，当controller出现异常时，会自动寻找本类中的加有ExceptionHandler注解的方法，参数可以指定异常类型,进行一个出错后的跳转

```java
@ExceptionHandler(value= {ArithmeticException.class})
@ResponseBody
public String exception(Exception ex) {
    return "error";
}
```

当本类中没有这个方法时，会去寻找加了ControllerAdvice的类中适配对应的方法

```java
@ControllerAdvice
public class ExceptionDo {

	@ExceptionHandler(value= {ArithmeticException.class})
	@ResponseBody
	public String exception(Exception ex) {
		return "xxx";
	}
}
```

