# 反射 reflect

## Class类

1, Class是一个类,用来描述类的类

2,描述了一个类的属性，方法，注解等

3，每个类jvm都会仅保留一个不变的Class类型的对象

4,Class对象只能由系统创建

**获取Class对象**

1,通过类名`.class`获取

```java
Class studengClass=Student.class;
```

2,对象`.getClass()`方法

```java
Class stringClass = "".getClass();
```

3,`Class.forName(全类名)`

如果全类名字符串拼错，该方法会抛出`ClassNotFoundException`异常

```java
 Class personClass = Class.forName("com.plf.zoe.model.Person");
```

## 创建对象

定义一个普通的bean类

```java
public class Person {
    
    private String name;
    
    public Person(){
        System.out.println("默认无参构造器");
    }

    public Person(String name) {
        System.out.println("有参构造器");
        this.name = name;
    }
}

```

通过反射得到Class对象，调用`newInstance`方法则会调用默认的无参构造器创建对象

```java
Class personClass = Class.forName("com.plf.zoe.model.Person");
Object p = personClass.newInstance();//默认无参构造器
System.out.println(p);//com.plf.zoe.model.Person@3d82c5f3
```

养成习惯，无论怎样都声明一个无参构造器

## 类加载器 ClassLoader

类加载分为引导类加载器(bootstrap)和用户类自定义加载器

引导类加载器 : 用来加载jdk核心类库，无法直接获取

扩展类加载器：用来加载jdk_home/lib/ext下的类

系统类加载器：用来加载用户的类

```java
public class ReflectTest {

    @Test
    public void test1() throws Exception {

        //系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

        //扩展类加载器，
        ClassLoader extClassloader = systemClassLoader.getParent();
        System.out.println(extClassloader);//sun.misc.Launcher$ExtClassLoader@31befd9f

        //引导类加载器
        ClassLoader bootstrapClassLoader = extClassloader.getParent();
        System.out.println(bootstrapClassLoader);//null

        //当前类的类加载器，为系统类加载器
        ClassLoader currentClassLoader = this.getClass().getClassLoader();
        System.out.println(currentClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

        //为引导类加载器
        ClassLoader langClassLoader = Class.forName("java.lang.Object").getClassLoader();
        System.out.println(langClassLoader);//null
    }
}
```

类加载器的常用方法

获取系统类加载器，调用`getResourceAsStream`得到类路径下的文件，转换为流

```java
//当前类的类加载器，为系统类加载器
ClassLoader currentClassLoader = this.getClass().getClassLoader();
System.out.println(currentClassLoader);

InputStream is = currentClassLoader.getResourceAsStream("db.properties");
Properties properties=new Properties();
properties.load(is);
System.out.println(properties.getProperty("jdbc.username"));
```

