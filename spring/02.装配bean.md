# 装配Bean

spring允许使用三种方式装配你的bean，而且可以同时混着来,使用前需要加入jar包

最基本的spring需要aop,core,beans,expression,context五个包还需要日志包spring4的版本使用commons-logging,spring5的版本使用spring-jcl包,推荐使用maven来管理依赖包,只需要导入context的依赖，会自动依赖其他的包

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.1.5.RELEASE</version>
</dependency>
```

## 自动化装配

自动化装配是最方便的方式，不用显示的声明bean，通过扫描自动装配

装配主要通过两个角度:

**组件扫描**(component scan):自动发现并创建bean

**自动装配**(auto wiring):管理bean之间的依赖关系

只需要在要创建的bean上打上注解，该类就会被创建

### Component

我们在学习任务类上打上**Component**注解,可以设置属性为bean命名

```java
@Component("studyJob")
public class StudyJob implements Job {

    @Override
    public void work() {
        System.out.println("studying...");
    }
}
```

### AutoWired

在GoodStudent中注入StudyJob,使用**AutoWired**注解,容器中只要有该类型的实例便会自动注入，而且不需要再构造方法中声明，也不用写set方法

AutoWired也可以打在任何方法上,只要这个方法中有对应类型的参数，spring便会在构造bean的时候注入对应的bean,如果没有对应的对象则会报错

如果不一定需要可以给AutoWired设置属性 `required = false`,没有对应的bean便不会调用该方法，但是需要自己做null检查

```java
@Component
public class GoodStudent implements Person {

    @Autowired
    private Job job;

    @Autowired(required = false)
    public void aaa(Teacher teacher){
        System.out.println(teacher);
    }
    
    @Override
    public void doWork() {
        job.work();
    }
}
```

### 开启扫描

当然组件扫描不是默认开启的，需要在配置类或者xml中声明

#### 使用配置类

使用**Configuration**注解声明这是一个配置类，使用**ComponentScan**开启注解扫描，默认会扫描当前配置类所在的包和其下的所有子包，也可以通过**basePackages**指定要扫描的包

由于指定包名是通过字符串，可以通过**basePackageClasses**指定类，就会扫描指定的类所在包的组件,方便编译期间发现问题

```java
@Configuration
@ComponentScan(basePackages = {"com.plf.spring"})
@ComponentScan(basePackageClasses = {Person.class, Job.class})
public class StudentConfig {
}
```

通过容器得到对象

```java
@Test
public void test5(){
    //加载配置类
    ApplicationContext context=new AnnotationConfigApplicationContext(StudentConfig.class);
    //得到bean
    GoodStudent student = context.getBean(GoodStudent.class);
    student.doWork();
}
```

#### 使用xml

通过xml的方式配置，需要spring专门的xml约束，建议使用sts或者idea等开发工具去生成，错误的约束，会导致解析xml失败，很难发现问题

通过context:component-scan标签指定扫描的包即可，需要加context的约束

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.plf.spring"/>
    
</beans>
```

运行

```java
@Test
public void test3(){
    //从类路径下加载xml配置文件
    ApplicationContext context=new ClassPathXmlApplicationContext("spring/student.xml");
    //得到bean
    GoodStudent student = context.getBean(GoodStudent.class);
    student.doWork();
}
```

### 整合junit

此时我们发现一个问题，进行junit测试的时候，每次都需要得到context上下文对象，才能得到bean，可以通过spring-test去整合junit,引入依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>5.1.5.RELEASE</version>
    <scope>test</scope>
</dependency>
```

单元测试.指定通过`SpringRunner.class`来运行，通过ContextConfiguration注解来加载Context

```java
//@RunWith(SpringJUnit4ClassRunner.class) spring4.3之前的版本使用这个类
//@ContextConfiguration(classes = {StudentConfig.class}) classes和locations不能同时使用

@RunWith(SpringRunner.class)
@ContextConfiguration(locations = {"classpath:spring/student.xml"})
public class JobTest {

    @Autowired
    GoodStudent student;

    @Test
    public void test1(){
        student.doWork();
    }
}
```



## 配置类

尽管自动扫描很方便，但是还是不能适用于所有情况，比如你需要使用第三方的对象，但是不能进入它的源代码去修改它们的类，打上注解,这时候就需要显示的声明配置

## 配置文件

虽然推荐使用配置类，但是使用xml的方式是spring一开始就一直支持的方式，依旧有很多新老项目一直使用xml这种传统的方式来做配置，是有必要去学习的

