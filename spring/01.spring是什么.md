# spring 是什么

spring是一框架，旨在用aop和ioc减少样板代码，解耦的框架

## 依赖注入

DI是dependency inject的简写,为了解决耦合，如下例子

有一个学习任务类,会执行学习的过程

```java
public class StudyJob implements Job {

    @Override
    public void work() {
        System.out.println("studying...");
    }
}
```

一个学生类,属性中有学习任务

```java
public class Student implements Person {

    private StudyJob job=new StudyJob();

    @Override
    public void doWork() {
        job.work();
    }
}
```

当我们创建学生，执行学生的doWork方法，会执行任务的work方法

```java
@Test
public void test1(){
    Student student=new Student();
    student.doWork();
}
```

可以看到，学习任务是直接作为学生的属性，学生和学习任务紧密的耦合在了一起，极大的限制了学生的能力，如果学生今天也许要打扫卫生，收作业等其他工作，便需要编写专门用来打扫卫生的学生

所以要通过依赖注入，来协调第三方的依赖，学生无需在意要执行什么任务，任务会自动注入到对应的学生中去

请看别人家的小孩GoodStudent,这里属性中是一个job接口，通过构造方法或者set方法将要执行的任务注入，再执行任务，只要实现了job接口的任务，都可以执行，就不用在意具体是任务了，实现了松耦合

```java
public class GoodStudent implements Person {
    
    private Job job;

    public GoodStudent() {
    }

    public GoodStudent(Job job) {
        this.job = job;
    }
    
    public void setJob(Job job) {
        this.job = job;
    }

    @Override
    public void doWork() {
        job.work();
    }
}
```

通过构造方法或者set方法注入任务,无需再编写对应的学生，只需要将工作交给学生即可

```java
@Test
public void test2(){
    GoodStudent student1=new GoodStudent(new CleanJob());

    GoodStudent student2=new GoodStudent();
    student2.setJob(new StudyJob());

    student1.doWork();
    student2.doWork();
}
```

## 面向切面编程

AOP是aspect-oriented programing 的简写，以为面向切面编程

通常一个类除了要执行它应该执行的任务，还会执行一些别的任务，比如日志，安全，事物等系统服务

比如学生开始工作前后都要通知老师

```java
public class Teacher {
    
    public void startJob(){
        System.out.println("start ok");
    }
    
    public void endJob(){
        System.out.println("end ok");
    }
}
```

学生执行任务前都要通知老师

```java
public class GoodStudent implements Person {

    private Job job;
    private Teacher teacher;

    public GoodStudent() {
    }

    public GoodStudent(Job job,Teacher teacher) {
        this.job = job;
        this.teacher=teacher;
    }

    @Override
    public void doWork() {
        teacher.startJob();//通知老师开始工作
        job.work();
        teacher.endJob();//工作结束通知完成
    }
}
```

执行任务需要把任务和老师都注入进来

```java
GoodStudent student1=new GoodStudent(new CleanJob(),new Teacher());
student1.doWork();
```

但是学生应该只要做好自己本身的工作就好了，而不应该去管理老师，样板性的代码，会让已有的逻辑变得复杂，导致一个类不能专注于自己的任务，就像事物，每次都是开启事物，插入数据，关闭事物，来确保数据库的安全，重复性的代码，会导致代码变得臃肿

## 容器

spring 的容器负责管理对象，使其相互协作，在spring中主要有两种容器，BeanFactory和ApplicationContext,这边主要讨论ApplicationContext

ApplicationContext是一个接口，拥有多种实现

| 实现类                                | 作用                                         |
| ------------------------------------- | -------------------------------------------- |
| ClassPathXmlApplicationContext        | 从类路径下读取xml文件加载上下文对象(context) |
| FileSystemXmlApplicationContext       | 从文件系统路径下加载xml文件加载应用上下文    |
| XmlWebApplicationContext              | 从web应用下加载xml文件加载上下文             |
| AnnotationConfigApplicationContext    | 基于java的配置类加载应用上下文               |
| AnnotationConfigWebApplicationContext | 基于java的配置类加载web应用上下文            |

使用方法,

```java
//从类路径下加载配置文件  常用
ApplicationContext context=new ClassPathXmlApplicationContext("spring/student.xml");
//从系统路径下加载配置文件
ApplicationContext context=new FileSystemXmlApplicationContext("d:/student.xml");
//加载配置类  常用
ApplicationContext context=new AnnotationConfigApplicationContext(StudentConfig.class);
//其他两种在web中详解
```

## Bean的生命周期

1,实例化

2,填充属性

3,调用BeanNameAware的setBeanName方法

4,调用BeanFactoryAware的setBeanfactory方法

5,调用ApplicationContextAware的setApplicationContext方法

6,调用BeanPostProcessor的预初始化方法

7,调用InitialzingBean的afterPropertiesSet方法

8,调用自定义的初始化方法

9,调用BeanPostProcessor的初始化后方法

10,可用状态

11,容器关闭

12,调用DisposableBean的destory方法

13,调用自定义销毁方法

从创建到销毁的若干阶段，都可以通过实现接口，或指定方法来对bean做自定义的处理

```java
package com.plf.spring.person;

import com.plf.spring.job.StudyJob;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.*;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class Student implements Person, BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean , DisposableBean {

    private StudyJob job=new StudyJob();

    @Override
    public void doWork() {
        job.work();
    }

    @Override
    public void setBeanName(String s) {
        System.out.println("BeanNameAware setBeanName");
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println("BeanFactoryAware setBeanFactory");
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        System.out.println("ApplicationContextAware setApplicationContext");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("InitializingBean afterPropertiesSet");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("DisposableBean destroy");
    }

    //自定义的销毁方法
    public void myDestroy(){
        System.out.println("myDestroy");
    }

    //自定义的初始化方法
    public void myInit(){
        System.out.println("myInit");
    }

}
```

在配置文件中配置bean并指定自定义初始化方法和销毁方法

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.plf.spring.person.Student"
          init-method="myInit"
          destroy-method="myDestroy"/>

</beans>
```

测试代码

```java
ApplicationContext context=new ClassPathXmlApplicationContext("spring/student.xml");
Student s = context.getBean(Student.class);
s.doWork();
//销毁
((ClassPathXmlApplicationContext) context).close();
```

执行结果

```
BeanNameAware setBeanName
BeanFactoryAware setBeanFactory
ApplicationContextAware setApplicationContext
InitializingBean afterPropertiesSet
myInit
studying...

DisposableBean destroy
myDestroy
```



