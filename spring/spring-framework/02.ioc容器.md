# ioc容器

ioc 容器通过配置，对象通过构造方法，工厂方法，或设置属性创建实例，然后注入依赖项

核心接口`BeanFactory`,提供了容器的基本功能，而`ApplicationContext`是它的子类，提供了更多的功能

`ApplicationContext`通过xml配置，java配置类，java注解等方式获取配置信息，通过配置信息实例化一个可用的对象，通常称之为bean

在独立的应用程序中，通常使用`FileSystemXmlApplicationContext` 和 `ClassPathXmlApplicationContext` 来读取xml形式的配置文件，并得到上下文对象

配置过程为，业务类+配置 传入 容器，得到可用的业务类实例

而spring的xml配置推荐使用idea和sts生成

引入依赖spring-context

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.1.RELEASE</version>
</dependency>
```

在类路径下（对应maven项目的resources下），生成spring的xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>
```

读取类路径下的配置文件，创建上下文实例

```java
ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
```

可以传入多个配置文件,不同配置下同一个容器的bean可以相互引用

```java
ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml","spring-context.xml");
```

或是在一个xml配置中引入其他配置，通过`import`标签指定路径

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <import resource="spring/spring-context.xml"/>

</beans>
```

相对路径不推荐使用`../` 。也可以加上`classpath:`前缀指定类路径的绝对路径

```xml
<import resource="classpath:/spring/spring-context.xml"/>
```

容器实例化就可以使用了，假如你有如下配置,定义了一个student

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.plf.spring.model.Student">
        <property name="studentId" value="123"/>
        <property name="studentName" value="zs"/>
    </bean>
    
</beans>
```

直接使用`getBean`方法指定id得到该对象，接下来会详解bean的配置

```java
Student student = context.getBean("student", Student.class);
```

# bean 配置

## 命名

一个bean通过id和name来指定名称，id在一个容器中是**唯一**的。如果不指定id，容器会默认给一个唯一的id，如果想要指定别名，使用name，可以通过  逗号`,` 分号 `;` 和空格隔开多个别名。

如果一个bean不会被别的bean引用，可以不指定id和name 

```xml
<bean id="student" name="student2,student3;student4 student5" class="com.plf.spring.model.Student">
    <property name="studentId" value="123"/>
    <property name="studentName" value="zs"/>
</bean>
```

使用的时候，id和name都可以得到bean

```java
Student student = context.getBean("student2", Student.class);
```

还可以通过`alias`标签在外部指定别名

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <property name="studentId" value="123"/>
    <property name="studentName" value="zs"/>
</bean>

<alias name="student" alias="student6"/>
```

## 实例化

### 无参构造器

大多数情况下，通过无参构造器创建实例，通过class属性指定全类名即可

```java
<bean id="student" class="com.plf.spring.model.Student"/>
```

需要有一个无参构造器,实例化的时候会调用该方法

```java
public Student() {
    System.out.println("empty param constructor");
}
```

### 静态工厂方法

假如我们想通过某个工厂类的静态方法得到实例

```java
public class StudentFactory {
    public static Student createStudent(){
        return new Student();
    }
}
```

则指定class属性为工厂类，和`factory-method`属性指定一个静态方法

```xml
<bean id="student2" class="com.plf.spring.factory.StudentFactory" factory-method="createStudent"/>
```

### 实例工厂方法

如果该工厂创建实例的方法不是静态方法

```java
public class StudentFactory {
    public Student createStudent(){
        return new Student();
    }
}

```

则需要先实例化工厂，通过`factory-bean`指定工厂实例的引用，再指定创建实例的方法

```xml
<bean id="studentFactory" class="com.plf.spring.factory.StudentFactory"/>

<bean id="student2" factory-bean="studentFactory" factory-method="createStudent"/>
```

# 依赖注入

当一个要实例化的对象，需要一些属性的时候，通过依赖注入设置属性

`ref` 属性指定依赖的实例对象 ，`value` 属性指定值

## 构造注入

使用构造方法注入依赖

当不存歧义时，可以直接使用通过ref引入实例，注入到属性中

```java
public class Student {

    private Book book;
    private Subject subject;

    public Student() {
    }

    public Student(Book book, Subject subject) {
        this.book = book;
        this.subject = subject;
    }
}
```

当不存歧义时，可以直接使用`constructor-arg` ,无关参数类型和顺序

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <constructor-arg ref="subject"/>
    <constructor-arg ref="book"/>
</bean>

<bean id="book" class="com.plf.spring.model.Book"/>

<bean id="subject" class="com.plf.spring.model.Subject"/>
```

### 指定类型

可以通过指定类型消除歧义

```java
public class Student {

    private String stuName;
    private int age;

    public Student() {
    }

    public Student(String stuName, int age) {
        this.stuName = stuName;
        this.age = age;
    }
}
```

通过type指定数据类型

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <constructor-arg type="int" value="123"/>
    <constructor-arg type="java.lang.String" value="321"/>
</bean>
```

### 指定下标

通过index属性指定参数顺序，从0开始

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <constructor-arg index="0" value="123"/>
    <constructor-arg index="1" value="321"/>
</bean>
```

### 指定名称

还可通过name属性指定参数名称

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <constructor-arg name="stuName" value="123"/>
    <constructor-arg name="age" value="321"/>
</bean>
```

## setter注入

通过`property` 标签指定属性名称，对象通过ref，值通过value注入

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <property name="book" ref="book"/>
    <property name="stuName" value="zs"/>
</bean>

<bean id="book" class="com.plf.spring.model.Book"/>
```

## 工厂方法注入参数

```java
public class StudentFactory {
    public static Student createStudent(String stuName, Book book){
        Student student = new Student();
        student.setBook(book);
        student.setStuName(stuName);
        return student;
    }
}
```

如果使用工厂方法，则需要通过`constructor-arg`标签传入参数

```xml
<bean id="student" class="com.plf.spring.factory.StudentFactory" factory-method="createStudent">
    <constructor-arg name="stuName" value="zs"/>
    <constructor-arg name="book" ref="book"/>
</bean>

<bean id="book" class="com.plf.spring.model.Book"/>
```

## 引用bean名称

如果需要注入的不是一个类型的引用，而是bean的name的字符串

```java
public class Student {

    private String stuName;
    private String bookBeanName;
```

可以使用`idref` 来指定bean的名称

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <property name="bookBeanName">
        <idref bean="book"/>
    </property>
</bean>

<bean id="book" class="com.plf.spring.model.Book"/>
```

等价于以下配置,但是语义不同，上面会使ide检测到是否有这个bean名称，而下面只是和bean名称同名的字符串值，拼写错误不会触发编辑器的校验

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <property name="bookBeanName" value="book"/>
</bean>

<bean id="book" class="com.plf.spring.model.Book"/>
```

## 内部bean

当一个bean只会被引用一次，且不会被单独使用，可以使用内部bean

```java
public class Student {

    private String stuName;
    private Book book;
```

在property标签中指定bean，不需要指定id，就算指定id，容器也会忽略，内部bean始终是匿名的

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <property name="book">
        <bean class="com.plf.spring.model.Book"/>
    </property>
</bean>
```

## 引用集合

如果注入的对象是集合类型，list，map，set，properties

```java
public class Student {

    private List<Object> myList;
    private Set<Object> mySet;
    private Map<Object,Object> myMap;
    private Properties myProp;
```

可以使用对应的标签设置属性

```xml
<bean id="book" class="com.plf.spring.model.Book"/>

<bean id="student" class="com.plf.spring.model.Student">
    <property name="myList">
        <list>
            <value>aaaaaaaaa</value>
            <ref bean="book"/>
        </list>
    </property>

    <property name="mySet">
        <set>
            <value>aaaaaaaaaa</value>
            <ref bean="book"/>
        </set>
    </property>

    <property name="myMap">
        <map>
            <entry key="zz" value="yy"/>
            <entry key-ref="book" value-ref="book"/>
        </map>
    </property>

    <property name="myProp">
        <props>
            <prop key="a">zzz</prop>
            <prop key="b">yyy</prop>
        </props>
    </property>
</bean>
```

list标签使用value和ref分别指定值类型和对象类型,set同样如此

map标签使用entry标签，key指定值类型的键，value指定值类型的值，key-ref和value-ref指定对象类型

props使用prop子标签,key只能指定字符串类型的键，标签内容为值

## p空间与c空间

p空间用来替换property标签,约束需要引入`xmlns:p="http://www.springframework.org/schema/p"`

```xml
<bean id="student" class="com.plf.spring.model.Student" p:stuName="zs"/>
```

等价于

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <property name="stuName" value="zs"/>
</bean>
```

c标签用于替换constructor-arg,引用约束`xmlns:c="http://www.springframework.org/schema/c"`

```xml
<bean id="student" class="com.plf.spring.model.Student" c:stuName="zs"/>
```

等价于

```xml
<bean id="student" class="com.plf.spring.model.Student">
    <constructor-arg  name="stuName" value="zs"/>
</bean>
```

pc标签不如传统标签灵活，比如无法使用内部bean，引用集合等。某些情况可以简化，需考虑后合理使用

## 间接依赖

如果一个bean没有直接依赖另一个bean，但是希望在这个bean实例化之后实例化，可使用`depends-on`

```xml
<bean id="student" class="com.plf.spring.model.Student" depends-on="book,subject"/>

<bean id="book" class="com.plf.spring.model.Book"/>

<bean id="subject" class="com.plf.spring.model.Subject"/>
```

以上student会等待book和sunject都实例化后，再实例化

## 懒加载

默认情况下，实例化容器时，就会实例化所有的bean，可以指定懒加载，在第一次调用的时再实例化

```xml
<bean id="student" class="com.plf.spring.model.Student" lazy-init="true"/>
```

指定`lazy-init="true"`,设置为懒加载

也可以配置` default-lazy-init="true"`当前xml都为懒加载

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-lazy-init="true">


</beans>
```

# bean作用域

spring支持六种作用域

## 单例

单例模式是默认的作用域模式,指定`scope="singleton"`，通常不需要配置

```xml
<bean id="student" class="com.plf.spring.model.Student" scope="singleton"/>
```

## 原型

每次调用`getBean`方法时，会创造一个以该配置为原型的新对象,设置`scope="prototype"`

```xml
<bean id="student" class="com.plf.spring.model.Student" scope="prototype"/>
```

调用两次，是两个对象，尽管属性一致

```java
Student student = context.getBean("student", Student.class);
Student student2 = context.getBean("student", Student.class);
System.out.println(student.equals(student2));//false
```

## web

在web中还支持`request`,`session`,`application`,`wesocket`四个作用域

# 定制bean

spring提供了一组接口，用来定制

## 生命周期回调

### 初始化

方式一，实现接口`InitializingBean`，实例化时会自动调用`afterPropertiesSet`方法

```java
public class Student implements InitializingBean {

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("init student");
    }
}
```

```xml
<bean id="student" class="com.plf.spring.model.Student"/>
```

方式二，配置指定的初始化方法,配置`init-method="init"` ，则会在实例化后，调用一次指定的方法

```java
public class Student{

    public void init(){
        System.out.println("student init 2");
    }
}
```

```xml
<bean id="student" class="com.plf.spring.model.Student" init-method="init"/>
```

两种方法，各有好坏，根据场景使用，比如使用第三方包的类，无法修改源码，只能使用第二种方式

### 销毁

方式一,实现`DisposableBean`接口，，重写`destroy`方法

```java
public class Student implements DisposableBean {

    @Override
    public void destroy() throws Exception {
        System.out.println("student destroy");
    }
}
```

方式二，`destroy-method`指定销毁方法

```java
public class Student{

    public void clean() throws Exception {
        System.out.println("student destroy");
    }
}
```

```xml
<bean id="student" class="com.plf.spring.model.Student" destroy-method="clean"/>
```

## 感知接口

感知接口可以在bean实例化的过程中，给bean注入某些容器的属性

### ApplicationContextAware

该接口可以把当前的容器直接注入进来

```java
public class Student implements ApplicationContextAware {
    
    private ApplicationContext context;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException  	{
        this.context = applicationContext;
    }
    
    public void readBook(){
        Book book = context.getBean("book", Book.class);
    }
}
```

### BeanNameAware

该接口可以得到当前bean的id

```java
public class Student implements BeanNameAware {

    @Override
    public void setBeanName(String s) {
        System.out.println(s);
    }
}
```

# 容器扩展

## BeanPostProcessor

当我们需要在给bean的实例化前后，做些特殊操作时,可以自定义实例化前后回调方法

```java
public class BeanInitImpl implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("bean:"+beanName+" create before :" +bean.toString());
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("bean:"+beanName+" create after :" +bean.toString());
        return bean;
    }
}
```

实现`BeanPostProcessor`接口，重写对应方法

```xml
<bean id="student" class="com.plf.spring.model.Student"/>
<bean id="book" class="com.plf.spring.model.Book"/>

<bean class="com.plf.spring.init.BeanInitImpl"/>
```

当student和book实例化时，则会调用BeanInitImpl实现的两个回调方法,做特殊操作

## BeanFactoryPostProcessor

实现该接口，并注册，可以在容器实例化时回调

```java
public class BeanInitImpl implements BeanFactoryPostProcessor {

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        System.out.println("context init");
    }
}
```

```xml
<bean class="com.plf.spring.init.BeanInitImpl"/>
```

### PropertySourcesPlaceholderConfigurer

这是spring提供的工厂后处理器，可以读取properties文件，其他bean使用占位符`${}`设置其中的属性

```xml
<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="locations" value="classpath:a.properties"/>
</bean>

<bean id="student" class="com.plf.spring.model.Student">
    <property name="stuAge" value="${stuAge}"/>
</bean>
```

引入`context`命名空间后，可以使用`property-placeholder`,可以使用逗号指定多个文件

```xml
<context:property-placeholder location="classpath:a.properties,classpath:b.properties"/>
```

不单单会读取指定文件的属性，还会读取环境变量和系统属性

比如`${username}`会拿到当前电脑的用户名。`${java.home}`会拿到java的安装目录，如果环境变量有的话

### PropertyOverrideConfigurer

该工厂后置处理器，会覆盖配置的bean的属性

```xml
<bean class="org.springframework.beans.factory.config.PropertyOverrideConfigurer">
    <property name="locations" value="classpath:a.properties"/>
</bean>

<bean id="student" class="com.plf.spring.model.Student">
    <property name="stuName" value="zs"/>
    <property name="stuAge" value="123"/>
</bean>
```

properties文件中的属性，需要定义为`beanName.property=value`

```properties
student.stuName=ls
student.stuAge=321
```

创造的bean的属性，会被文件中的覆盖

引入`contex` 空间后，可以使用`property-override`来指定

```xml
<context:property-override location="classpath:a.properties"/>
```

## FactoryBean

如果有复杂的实例化方式，需要使用代码来创建，可以实现`FactoryBean`接口，指定返回类型和构造对象的过程

```java
public class StudentFactoryBean implements FactoryBean<Student> {
    @Override
    public Student getObject() throws Exception {
        Student student = new Student();
        student.setStuName("zs");
        return student;
    }

    @Override
    public Class<?> getObjectType() {
        return Student.class;
    }
}
```

```xml
<bean id="student" class="com.plf.spring.factory.StudentFactoryBean"/>
```

这个bean标签配置实例类型是`getObjectType`方法的返回类型,如果接口指定了泛型，则返回null也可以

```java
Student student = context.getBean("student", Student.class);
System.out.println(student);
```

如果希望直接使用`FactoryBean`的实例，则在id前加`&`符号

```java
FactoryBean<Student> factoryBean = context.getBean("&student", FactoryBean.class);
Student object = factoryBean.getObject();
```

