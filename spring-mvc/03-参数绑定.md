# 参数绑定

#### 1,简单类型

可以在参数中加简单类型的参数，只要名称一样就可以自动绑定

```java
@RequestMapping(value="test")
public String test(String id) {
    System.out.println("id:"+id);
    return "success";
}
```

请求的url

```html
<a href="${pageContext.request.contextPath }/student/test?id=001">to success</a>
```

如果参数名称不一致可以通过**@RequestParam**的value值来绑定对应的传过来的参数，required的默认值为true，代表参数是必须的，如果参数不存在，可以通过defaultValue来设置默认值

```java
@RequestMapping(value="test")
public String test(@RequestParam(value="id",defaultValue="zs",required=false) String userid) {
    System.out.println("id:"+userid);
    return "success";
}
```

类似的注解**@RequestHeader**可以拿到请求头的信息

```java
@RequestMapping(value="test")
public String test(@RequestHeader("Accept-Language") String al) {
    System.out.println("al:"+al);
    return "success";
}
```

#### 2,对象类型

直接使用对象作为参数，支持级联

```java
@RequestMapping(value="test")
public String test(StudentBean stu) {
    System.out.println("stu:"+stu);
    return "success";
}
```

参数会自动绑定到名称一致的属性中,没有参数为null

```html
<a href="${pageContext.request.contextPath }/student/test?id=001&student_name=zs">to success</a>
```

所有的自动绑定参数的情况

|                条件                |             结果             |
| :--------------------------------: | :--------------------------: |
|          参数名，类型一致          |       参数能够成功绑定       |
| 类型一致，参数名称不一致，或者没传 |          参数为null          |
|        名称一致，类型不一致        | 出现没有任何提示的400或者404 |

#### 3,servlet原生的对象

参数中可以直接放servlet自带的对象，当servlet用

```java
@RequestMapping(value="test")
public void test(HttpServletRequest request,
                 HttpServletResponse response,
                 HttpSession session,
                 Writer out) throws IOException {
    out.write("aaa");
}
```

### 4，ModelAttribute

ModelAttribute可以修饰参数和方法,

被@ModelAttribute修饰的方法会在当前controller执行任何方法前执行一次，会提前拿到参数

可以在参数中加Model对象，存储对象

```java
@ModelAttribute
public void bef1(Integer userid,Model model) {
    System.out.println("ValidController.bef() userid:"+userid);
    model.addAttribute("user1", new User(userid,"张三")) ;
}
```

或者直接返回这个对象，也会自动存储到Model对象中，如果不设置键，键默认是对应的类名首字母小写

```java
@ModelAttribute(name="user2")
public User bef(Integer userid,Model model) {
	System.out.println("ValidController.bef() userid:"+userid);
	return new User(userid,"张三");
}
```

接下来准备要执行的方法,**如果Model对象中有该类型的对象**,**会直接引用  使用该类名首字母小写作为键的对象，没有则不引用**

```java
@RequestMapping("pro")
@ResponseBody
public String pro(User user) {
    System.out.println("ValidController.pro() user:"+user);
    return "true";
}
```

如果一个controller存在多个ModelAttribute修饰的方法，会从上往下依次执行，如果设置同样的键，值会做一个覆盖。如果设置键不一样，则会存在多个键值对，可以通过@ModelAttribute修饰形参，拿指定的对象

```java
@RequestMapping("pro")
@ResponseBody
public String pro(@ModelAttribute(name="user2") User user) {
    System.out.println("ValidController.pro() user:"+user);
    return "true";
}
```

通常应用于修改操作,比如只修改name属性，且只传了name属性，其他属性为null，可以在ModelAttribute修饰的方法通过name把对象信息补全，防止接下来修改了其他属性为null

### 5,@SessionAttributes和@SessionAttribute

**@SessionAttributes**用来修饰类,通过参数**value**或者**types**可以把**Model**对象中的有的缓存到**session**中，

```java
@Controller
@SessionAttributes(value= {"user1"}，types= {User.class})
public class ValidController {
```

**@SessionAttribute**用来修饰参数，让这个参数引用session域中的对象

```java
@RequestMapping("pro")
@ResponseBody
public String pro(@SessionAttribute(name="user1",required=false) User user,HttpSession session) {
    System.out.println("ValidController.pro() sessionScope->user  "+session.getAttribute("user1"));
    System.out.println("ValidController.pro() user:"+user);
    return "true";
}
```

测试session相关的业务，会有缓存,多试几次

## 类型转化

1，在springMVC中，可以直接把yyyy-MM-dd类型转化为java.sql.Date类型,如果这个参数要存入数据库，推荐直接使用java.sql.Date作为属性,不过不能精确到秒

例如,html输入类型使用date型

```html
<form action="/spring-mvc-02/testTime.do" method="post">
	<input type="date" name="birthday"><br/>
	<input type="submit" value="生日">
</form>
```

对应的controller可以直接使用java.sql.Date接

```java
@RequestMapping("testTime")
@ResponseBody
public String xxx(java.sql.Date birthday) {
    System.out.println(birthday);
    return "a";
}
```

2，如果想要使用自己输入的字符串，想转成java.util.Date类型,就需要自定义类型转换器

编写转换器,实现Converter接口，指定泛型类型，第一个是入参，第二个是出参，以下配置就表示，凡是遇到string转date的情况调用这个转换器

```java
@Component
public class DateTimeConverter implements Converter<String,Date>{

	@Override
	public Date convert(String arg0) {
		SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
		Date date=null;
		try {
			date = format.parse(arg0);
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return date;
	}
}
```

注册转换器

```xml
<mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven>
<!--在注解驱动中启用转化服务-->
<!--注册转化器到转换器工厂-->
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <set>
            <ref bean="dateTimeConverter"/>
        </set>
    </property>
</bean>
```

测试代码

```java
@RequestMapping("testTime")
@ResponseBody
public String xxx(java.util.Date birthday) {
    System.out.println(birthday);
    return "a";
}
```

输入框中输入  2012-12-12 12:12:12，，得到的java对象为    Wed Dec 12 00:12:12 CST 2012